name: CI/CD - Production Deployment

on:
  push:
    branches:
      - main
      - master
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deploy to environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
      confirm_production:
        description: 'Type "DEPLOY-PRODUCTION" to confirm'
        required: true
        type: string

env:
  AZURE_RESOURCE_GROUP: PCI-prod
  AKS_CLUSTER_NAME: pci-production-aks
  ACR_NAME: pciregistry
  NAMESPACE: pci-production

jobs:
  validate-production:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
    - name: Validate Production Deployment
      run: |
        if [ "${{ github.event.inputs.confirm_production }}" != "DEPLOY-PRODUCTION" ]; then
          echo "‚ùå Production deployment not confirmed. Exiting."
          exit 1
        fi
        echo "‚úÖ Production deployment confirmed"

  test:
    runs-on: ubuntu-latest
    name: Run Tests
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js for Backend
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: PCI-backend/package-lock.json

    - name: Install Backend Dependencies
      run: |
        cd PCI-backend
        npm install

    - name: Run Backend Tests
      run: |
        cd PCI-backend
        npm test

    - name: Setup Node.js for Frontend
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: PCI/package-lock.json

    - name: Install Frontend Dependencies
      run: |
        cd PCI
        npm install

    - name: Build Frontend
      run: |
        cd PCI
        npm run build

  build-and-deploy-production:
    needs: [test, validate-production]
    if: always() && (needs.test.result == 'success') && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && needs.validate-production.result == 'success'))
    runs-on: ubuntu-latest
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_PRODUCTION }}

    - name: Login to ACR
      run: |
        az acr login --name ${{ env.ACR_NAME }}

    - name: Build and push Backend image
      run: |
        cd PCI-backend
        docker build -t ${{ env.ACR_NAME }}.azurecr.io/pci-backend:${{ github.sha }} .
        docker tag ${{ env.ACR_NAME }}.azurecr.io/pci-backend:${{ github.sha }} ${{ env.ACR_NAME }}.azurecr.io/pci-backend:latest
        docker push ${{ env.ACR_NAME }}.azurecr.io/pci-backend:${{ github.sha }}
        docker push ${{ env.ACR_NAME }}.azurecr.io/pci-backend:latest

    - name: Build and push Frontend image
      run: |
        cd PCI
        docker build -t ${{ env.ACR_NAME }}.azurecr.io/pci-frontend:${{ github.sha }} .
        docker tag ${{ env.ACR_NAME }}.azurecr.io/pci-frontend:${{ github.sha }} ${{ env.ACR_NAME }}.azurecr.io/pci-frontend:latest
        docker push ${{ env.ACR_NAME }}.azurecr.io/pci-frontend:${{ github.sha }}
        docker push ${{ env.ACR_NAME }}.azurecr.io/pci-frontend:latest

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER_NAME }}

    - name: Create namespace if not exists
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Create/Update secrets
      run: |
        # Create database secrets
        kubectl create secret generic pci-postgres-secrets \
          --namespace=${{ env.NAMESPACE }} \
          --from-literal=postgres-user=${{ secrets.POSTGRES_USER }} \
          --from-literal=postgres-password=${{ secrets.POSTGRES_PASSWORD }} \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Create backend secrets
        kubectl create secret generic pci-backend-secrets \
          --namespace=${{ env.NAMESPACE }} \
          --from-literal=database-url=${{ secrets.DATABASE_URL_PRODUCTION }} \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Create frontend secrets
        kubectl create secret generic pci-frontend-secrets \
          --namespace=${{ env.NAMESPACE }} \
          --from-literal=nextauth-secret=${{ secrets.NEXTAUTH_SECRET }} \
          --from-literal=database-url=${{ secrets.DATABASE_URL_PRODUCTION }} \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Update image tags in Kustomization
      run: |
        # Update production kustomization with new image tags
        sed -i "s|newTag: latest|newTag: ${{ github.sha }}|g" k8s/overlays/production/kustomization.yaml

    - name: Deploy to Production
      run: |
        kubectl apply -k k8s/overlays/production/ --namespace=${{ env.NAMESPACE }}

    - name: Wait for deployment
      run: |
        kubectl rollout status deployment/pci-backend --namespace=${{ env.NAMESPACE }} --timeout=600s
        kubectl rollout status deployment/pci-frontend --namespace=${{ env.NAMESPACE }} --timeout=600s

    - name: Run Database Migrations
      run: |
        # Wait for backend pod to be ready
        kubectl wait --for=condition=ready pod -l app=pci-backend -n ${{ env.NAMESPACE }} --timeout=300s
        
        # Get backend pod name and run migrations
        POD_NAME=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=pci-backend -o jsonpath='{.items[0].metadata.name}')
        kubectl exec -n ${{ env.NAMESPACE }} $POD_NAME -- npm run drizzle:migrate

    - name: Health Check
      run: |
        # Get ingress IP and test health endpoints
        sleep 30  # Wait for ingress to update
        kubectl get ingress --namespace=${{ env.NAMESPACE }}
        
        # Test backend health
        POD_NAME=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=pci-backend -o jsonpath='{.items[0].metadata.name}')
        kubectl exec -n ${{ env.NAMESPACE }} $POD_NAME -- curl -f http://localhost:3000/health || exit 1

    - name: Production Deployment Summary
      run: |
        echo "üèÜ Paralympic Committee of India - PRODUCTION DEPLOYED! üèÜ"
        echo "========================================================"
        echo "Environment: PRODUCTION"
        echo "Namespace: ${{ env.NAMESPACE }}"
        echo "Backend Image: ${{ env.ACR_NAME }}.azurecr.io/pci-backend:${{ github.sha }}"
        echo "Frontend Image: ${{ env.ACR_NAME }}.azurecr.io/pci-frontend:${{ github.sha }}"
        echo "Deployment Time: $(date)"
        echo "========================================================"
        
        # Get service info
        kubectl get services --namespace=${{ env.NAMESPACE }}
        kubectl get ingress --namespace=${{ env.NAMESPACE }}

    - name: Notify Success
      if: success()
      run: |
        echo "‚úÖ Paralympic Committee of India production deployment successful!"
        echo "üåê Website should be available shortly"

    - name: Notify Failure
      if: failure()
      run: |
        echo "‚ùå Paralympic Committee of India production deployment failed!"
        echo "üîß Check the logs above for details"
